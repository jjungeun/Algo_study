# Big-O

알고리즘의 시간복잡도, 공간복잡도를 나타낸다. 



### 시간 복잡도

**최선의 경우, 최악의 경우, 평균적인 경우**

퀵 정렬을 예로 살펴보자. 퀵 정렬은 축이 되는 한 원소를 기준으로 작은 원소는 앞에, 큰 원소는 뒤에 놓이도록 부분 정렬을 하고 앞과 뒤에서 재귀적으로 정렬하는 알고리즘이다.

* 최선의 경우 : 모든 원소가 동일한 경우 배열을 한번 순회만 하고 끝난다. 즉 수행시간이 O(N)이 된다.
* 최악의 경우 : 배열에서 가장 큰 원소가 계속해서 축이 되는 경우, 재귀 호출이 배열을 절반으로 나누지 못하고 하나 줄어든 크기로 정렬하게 된다. 따라서 수행시간은 O(n^2)이 된다.
* 평균적인 경우 : 위와 같이 극단적인 경우를 제외하면, 축이 되는 원소가 가장 작거나 클 순 있지만 반복적으로 일어나는 일은 많지 않으므로 평균적으로 θ(NlogN)이 된다. (단계가 넘어갈수록 배열의 크기가 반으로 줄어드니까 정렬하는 시간이 logN이고 재귀가기 전 비교하는 시간이 N이므로)

많은 알고리즘은 최악의 경우와 평균적인 경우가 같다. 가끔 달라서 두 경우 모두 언급해야 되기도 한다.

big-O big-Ω , big-θ 는 각각 상한, 하한, 딱 맞는 수행시간을 의미한다.



### 공간 복잡도

알고리즘에선 공간복잡도 또한 고려해야한다. 크기가 n인 배열을 만들려고 하면, O(n)의 공간이 필요하다. n * n크기의 2차원 배열을 만들고자 한다면, O(n^2)의 공간이 필요하다.

**재귀호출 에서의 공간 복잡도**

재귀호출에서 사용되는 스택공간도 공간복잡도 계산에 포함된다. 예를들어 다음의 코드는 O(n)시간과 O(n)공간을 사용한다. 이 재귀호출은 전부 스택에 더해지고, 실제 메모리 공간을 잡아먹는다.

```
int sum(int n)
{
	if(n <= 0)
		return (0);
	return n + sum(n - 1);
}
```

**(중요)**하지만, n번 호출했다고 해서 O(n)의 공간을 사용한다고 말할 수는 없다. 다음의 함수를 살펴보자.

```
int pairSumSequence(int n)
{
	int sum = 0;
	for (int i=0; i<n; i++)
		sum += pairSum(i, i+1);
	return (sum);
}
```

이 코드는 ```pairSum```함수를 n번 호출했지만, **함수들이 호출 스택에 동시에 존재하지 않으므로, O(1)의 공간만 사용**한다.



### 지배적이지 않은 항은 무시하기

O(N^2 + N)의 경우는 어떻게 해야 할까? O(N^2 + N^2) = O(2 * N^2)에서 상수항인 2는 무시한다. 그렇다면 그보다 작은 N도 무시해도 된다는 뜻이다. 같은 논리로, O(N + logN)은 O(N)이 된다. 하지만 여기서 간과하면 안되는 것은, 예를 들어 O(B + A)는 하나의 항으로 줄일 수 없다.(A와 B사이에 특별한 관계가 있지 않는 이상)



### 여러 부분으로 이루어진 알고리즘 : 덧셈 vs 곱셈

덧셈 수행시간 : O(A+B)

```
for (int a: arrA)
	print(a);
for (int b: arrB)
	print(b);
```

곱셈 수행시간 : O(A * B)

```
for (int a: arrA)
	for (int b: arrB)
		print(a + b);
```



### 상환시간

ArrayList는 동적 가변크기 배열이다. 만약 배열이 가득 차면 기존 배열 크기의 2배만큼 동적으로 할당하고, 새 배열로 복사를 한다. 이 경우 삽입 연산은 O(N) 시간이 소요된다. 하지만 이렇게 배열이 가득 차 있는 경우는 극히 드물다. 대다수의 경우엔 가용공간이 존재하고, 이 때 삽입 연산은 O(1) 시간이 걸린다.

그렇다면 , 두가지 경우를 모두 포함한 전체 수행 시간을 따져봐야 하는데, 여기서 **상환시간** 개념을 이용하면 쉽게 구할 수 있다. 최악의 경우는 가끔 발생하지만 한번 발생하면 그 후로 꽤 오랫동안 나타나지 않으므로 수행시간을 분할 상환 한다는 개념이다. 따라서 위의 경우, 1 + 2 + 4 + 8 + ... + X이므로 합은 대략 2X이다. X개의 원소를 삽입했을 때 필요한 시간은 O(2X)이고, 분할상환해보면 삽입 한번에 필요한 시간은 O(1)이다.



### (중요) logN 수행시간

이진 탐색을 생각해보자. 중간값으로 비교하는 탐색이다. 처음엔 N개의 배열에서 시작해서 한 단계가 지나면  탐색할 원소 개수가 N/2로 줄어들고, 다음 단계에선 N/4, N/8로 줄어들다가 원소를 찾거나 원소가 하나가 남았을 때 중지한다.

총 수행시간은 N을 절반씩 나누는 과정에서 몇 단계만에 1이 되는지에 따라 결정된다. 예를들어 16에서 1이 되려면 몇 번 2로 나눠야 할까? 답은 4이다. 거꾸로 생각해 보면 2^k = N을 만족하는 k는 무엇일까? 이 때 사용되는 것이 **로그**이다.

**어떤 문제에서 원소 개수가 절반 씩 줄어든다면 수행시간은 O(logN)**이 될 가능성이 크다. 

여기서 로그의 밑은 중요할까? 중요하지 않다. 로그의 밑은 나눗셈으로 언제든지 변환할 수 있는데, 어차피 big-O표현식에서는 상수항을 버리기 때문이다.



### 재귀적으로 수행시간 구하기

```
int f(int n){
	if (n <= 1)
		return (1);
	return f(n - 1) + f(n - 1);
}
```

함수 f가 두번 호출되었다고 시간이 O(N^2)일까? f(4)를 예를들어 생각해 보면, 트리의 깊이가 1이 증가할 때 마다 2배씩 함수를 더 호출하게 된다. 따라서 수행시간은 O(2^N)이 된다. 

항상 그런건 아니지만 **다수의 호출로 이루어진 재귀함수에서 수행 시간은 보통 O(분기^깊이)**로 표현된다. 로그에선 밑을 무시하지만, 지수에서는 무시하면 안된다.

위 알고리즘에서 공간복잡도는 O(N)이 된다. 전체 노드 개수는 O(2^N)이지만, 특정 시각에 사용하는 공간의 크기는 O(N)이다. 따라서 필요한 가용 메모리크기는 O(N)이면 충분할 것이다.

---

### 예제

1. ```
   for(int i=0; i<N;i++)
   	for(int j=i+1; j<N; j++)
   		print(arr[i] + arr[j])
   ```

   이 경우는 시간복잡도가 얼마가 될까? 여러가지 방법으로 생각할 수 있지만, 가장 편한 방법인 **평균**을 이용해보자. 바깥 루프는 무조건 N번을 돈다. 안쪽은 N-1 , N-2, ,,, 1만큼 돈다. 이를 평균내면 N/2가 된다. 따라서 시간 복잡도는 O(N^2/2) = O(N^2)이 된다.

2. ```
   for(int i=0; i<arrA.length;i++)
   	for(int j=0; j<arrB.length; j++)
   		print(arrA[i] + arrB[j])
   ```

   이 경우는 다른 두개의 배열을 사용하는 경우이다. 이 경우는 단순히 O(N^2)이 아니라 O(AB)가 된다. 서로 다른 두개의 입력에 대해서 크기를 모두 고려해야한다.

3. **(중요)** 여러개의 문자열로 구성된 배열이 주어졌을 때, 각각의 문자열을 먼저 정렬하고 그 다음에 전체 문자열을 사전순으로 다시 정렬하는 알고리즘의 수행시간은 어떻게 될까?

   가정을 정의하고 시작하자.

   ```
   가장 길이가 긴 문자열의 길이를 s라고 하자.
   전체 문자열의 개수를 a라고 하자.
   ```

   - 각 문자열을 정렬하는데에 O(slogs)가 소요된다.
   - 총 문자열이 a개만큼 있으므로 O(a*slogs)가 문자열 정렬에 소요된다.
   - 그리고 전체 문자열을 정렬한다. 간단하게 O(aloga)가 소요된다고 생각하면 안된다.
   - **문자열을 비교하는 시간도 고려해야하기 때문이다.** 문자열 2개를 비교하는데 O(s)시간이 소요되고, 총 O(aloga)번을 비교해야하므로 O(a*sloga)가 된다.
   - 따라서 결론적으로 O(a*s(logs + loga))가 소요된다.

4. 문자열로 나타낼 수 있는 순열의 개수를 구하는 알고리즘의 시간 복잡도는 어떻게 될까?

   ```
   void permutation(String prefix, String str)
   {
   	if (str.length() == 0)
   		print(prefix);
   	else
   	{
   		for(int i=0; i<str.length(); i++)
   		{
   			String rem = str.substring(0, i) + str.substring(i+1);
   			permutation(prefix+str.charAt(i), rem);
   		}
   	}
   }
   ```

   **우선 재귀함수이므로 permutation함수가 몇번 호출되었는지 살펴보자.**

   몇번 호출되었는가는 순열의 가짓수를 생각해보면 된다. 순열의 가짓수는 n!이므로, **순열이 완성되는 시점에** permutation함수도 n!번 호출되었을 것이다.

   그렇다면 전체적으로는 몇번 호출되었을까? 호출트리를 생각해보면 루트에서 말단까지의 깊이가 n이 될것이다. 따라서 전체 노드의 개수는 **n*n!**개를 넘지 못한다.

   **그럼 이제 각 노드에서 걸리는 시간을 계산해보자.**

   if문에선 문자열을 출력하므로 O(N)시간이 걸린다. else문에서는 문자여를 연결하는 연산을 수행하므로 O(N)시간이 걸린다. rem, prefix, str.charAt(i)의 길이의 합은 항상 N이 된다.(문자열의 길이가 N을 넘을수 없다는 뜻) 따라서 각 호출 트리가 처리하는 일은 O(N)이 된다.

   **따라서 총 수행시간은 O(n^2*n!)을 넘지 않을 것이다.**

5. 피보나치 시리즈

   - 단순 피보나치

     ```
     int fib(int n)
     {
     	if (n <= 0) return 0;
     	else if (n == 1) return 1;
     	return fib(n - 1) + fib(n - 2);
     }
     ```

     이 알고리즘의 시간 복잡도는 O(2^N)이 된다.

   - 0부터 n까지 피보나치 수열을 전부 출력하는 알고리즘

     ```
     void allFib(int n)
     {
     	for(int i = 0;i < n;i++)
     		print(fib(n));
     }
     ```

     단순히 생각해서, 총 n번을 부르니까, O(N*2^N)이라고 생각했다. 그런데 중요한 점은 for문의 n과 피보나치의 n은 다르다는 것이다. 호출을 하나씩 살펴보자.

     fib(1) -> 2^1번 호출

     fib(2) -> 2^2번 호출

     . . .

     fib(n) -> 2^n번 호출

     따라서 fib(1) ~ fib(n)은 2^1 + 2^2 + ... + 2^n = 2^(n+1)이 된다. 상수항을 없애고나면 시간은 여전히 O(2^n)이 된다.

   - 이번엔 위와 똑같은데, 이 전에 계산된 결과를 저장하는 알고리즘이 있다고 생각하자. 

     이미 저장된 값이 있다면 캐시값을 반환한다. 이 때 수행시간은 어떻게 될까? 

     ```
     void allFib(int n)
     {
     	int[] memo = new int[n +1];
     	for(int i = 0;i < n;i++)
     		print(fib(n, memo));
     }
     
     int fib(int n, int[] memo)
     {
     	if (n <= 0) return 0;
     	else if (n == 1) return 1;
     	else if (memo[n] > 0) return memo[n];
     	memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
     	return memo[n];
     }
     ```

     fib(i)를 호출할 때마다, fib(i-1), fib(i-2)의 계산은 이미 끝나있고, 더한 값은 캐시 배열에 저장되어 있을 것이다. 따라서 단순히 캐시 값을 찾아 더한 뒤, 결과를 캐시값을 반환하기만 하면 된다. 이 과정은 재귀이긴 하지만 또 재귀로 들어가는게 아니므로 상수시간안에 끝나고, 이 과정을 for문으로 n번 반복하므로 **O(N)**시간이 걸린다.

     이렇게 지수시간이 걸리는 재귀알고리즘을 최적화할 때 쓰이는 방법중 하나인 메모이제이션 - Memoization을 기억하자!

   