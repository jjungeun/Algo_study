# Big-O

알고리즘의 시간복잡도, 공간복잡도를 나타낸다. 



### 시간 복잡도

**최선의 경우, 최악의 경우, 평균적인 경우**

퀵 정렬을 예로 살펴보자. 퀵 정렬은 축이 되는 한 원소를 기준으로 작은 원소는 앞에, 큰 원소는 뒤에 놓이도록 부분 정렬을 하고 앞과 뒤에서 재귀적으로 정렬하는 알고리즘이다.

* 최선의 경우 : 모든 원소가 동일한 경우 배열을 한번 순회만 하고 끝난다. 즉 수행시간이 O(N)이 된다.
* 최악의 경우 : 배열에서 가장 큰 원소가 계속해서 축이 되는 경우, 재귀 호출이 배열을 절반으로 나누지 못하고 하나 줄어든 크기로 정렬하게 된다. 따라서 수행시간은 O(n^2)이 된다.
* 평균적인 경우 : 위와 같이 극단적인 경우를 제외하면, 축이 되는 원소가 가장 작거나 클 순 있지만 반복적으로 일어나는 일은 많지 않으므로 평균적으로 θ(NlogN)이 된다. (단계가 넘어갈수록 배열의 크기가 반으로 줄어드니까 정렬하는 시간이 logN이고 비교하는 시간이 N이므로)

많은 알고리즘은 최악의 경우와 평균적인 경우가 같다. 가끔 달라서 두 경우 모두 언급해야 되기도 한다.

big-O big-Ω , big-θ 는 각각 상한, 하한, 딱 맞는 수행시간을 의미한다.



### 공간 복잡도

알고리즘에선 공간복잡도 또한 고려해야한다. 크기가 n인 배열을 만들려고 하면, O(n)의 공간이 필요하다. n * n크기의 2차원 배열을 만들고자 한다면, O(n^2)의 공간이 필요하다.

**재귀호출 에서의 공간 복잡도**

재귀호출에서 사용되는 스택공간도 공간복잡도 계산에 포함된다. 예를들어 다음의 코드는 O(n)시간과 O(n)공간을 사용한다. 이 재귀호출은 전부 스택에 더해지고, 실제 메모리 공간을 잡아먹는다.

```
int sum(int n)
{
	if(n <= 0)
		return (0);
	return n + sum(n - 1);
}
```

**(중요)**하지만, n번 호출했다고 해서 O(n)의 공간을 사용한다고 말할 수는 없다. 다음의 함수를 살펴보자.

```
int pairSumSequence(int n)
{
	int sum = 0;
	for (int i=0; i<n; i++)
		sum += pairSum(i, i+1);
	return (sum);
}
```

이 코드는 ```pairSum```함수를 n번 호출했지만, **함수들이 호출 스택에 동시에 존재하지 않으므로, O(1)의 공간만 사용**한다.



### 지배적이지 않은 항은 무시하기

O(N^2 + N)의 경우는 어떻게 해야 할까? O(N^2 + N^2) = O(2 * N^2)에서 상수항인 2는 무시한다. 그렇다면 그보다 작은 N도 무시해도 된다는 뜻이다. 같은 논리로, O(N + logN)은 O(N)이 된다. 하지만 여기서 간과하면 안되는 것은, 예를 들어 O(B + A)는 하나의 항으로 줄일 수 없다.(A와 B사이에 특별한 관계가 있지 않는 이상)



### 여러 부분으로 이루어진 알고리즘 : 덧셈 vs 곱셈

덧셈 수행시간 : O(A+B)

```
for (int a: arrA)
	print(a);
for (int b: arrB)
	print(b);
```

곱셈 수행시간 : O(A * B)

```
for (int a: arrA)
	for (int b: arrB)
		print(a + b);
```



### 상환시간

ArrayList는 동적 가변크기 배열이다. 만약 배열이 가득 차면 기존 배열 크기의 2배만큼 동적으로 할당하고, 새 배열로 복사를 한다. 이 경우 삽입 연산은 O(N) 시간이 소요된다. 하지만 이렇게 배열이 가득 차 있는 경우는 극히 드물다. 대다수의 경우엔 가용공간이 존재하고, 이 때 삽입 연산은 O(1) 시간이 걸린다.

그렇다면 , 두가지 경우를 모두 포함한 전체 수행 시간을 따져봐야 하는데, 여기서 **상환시간** 개념을 이용하면 쉽게 구할 수 있다. 최악의 경우는 가끔 발생하지만 한번 발생하면 그 후로 꽤 오랫동안 나타나지 않으므로 수행시간을 분할 상환 한다는 개념이다. 따라서 위의 경우, 1 + 2 + 4 + 8 + ... + X이므로 합은 대략 2X이다. X개의 원소를 삽입했을 때 필요한 시간은 O(2X)이고, 분할상환해보면 삽입 한번에 필요한 시간은 O(1)이다.



### (중요) logN 수행시간

이진 탐색을 생각해보자. 중간값으로 비교하는 탐색이다. 처음엔 N개의 배열에서 시작해서 한 단계가 지나면  탐색할 원소 개수가 N/2로 줄어들고, 다음 단계에선 N/4, N/8로 줄어들다가 원소를 찾거나 원소가 하나가 남았을 때 중지한다.

총 수행시간은 N을 절반씩 나누는 과정에서 몇 단계만에 1이 되는지에 따라 결정된다. 예를들어 16에서 1이 되려면 몇 번 2로 나눠야 할까? 답은 4이다. 거꾸로 생각해 보면 2^k = N을 만족하는 k는 무엇일까? 이 때 사용되는 것이 **로그**이다.

**어떤 문제에서 원소 개수가 절반 씩 줄어든다면 수행시간은 O(logN)**이 될 가능성이 크다. 

여기서 로그의 밑은 중요할까? 중요하지 않다. 로그의 밑은 나눗셈으로 언제든지 변환할 수 있는데, 어차피 big-O표현식에서는 상수항을 버리기 때문이다.



### 재귀적으로 수행시간 구하기

```
int f(int n){
	if (n <= 1)
		return (1);
	return f(n - 1) + f(n - 1);
}
```

함수 f가 두번 호출되었다고 시간이 O(N^2)일까? f(4)를 예를들어 생각해 보면, 트리의 깊이가 1이 증가할 때 마다 2배씩 함수를 더 호출하게 된다. 따라서 수행시간은 O(2^N)이 된다. 

항상 그런건 아니지만 **다수의 호출로 이루어진 재귀함수에서 수행 시간은 보통 O(분기^깊이)**로 표현된다. 로그에선 밑을 무시하지만, 지수에서는 무시하면 안된다.

위 알고리즘에서 공간복잡도는 O(N)이 된다. 전체 노드 개수는 O(2^N)이지만, 특정 시각에 사용하는 공간의 크기는 O(N)이다. 따라서 필요한 가용 메모리크기는 O(N)이면 충분할 것이다.

