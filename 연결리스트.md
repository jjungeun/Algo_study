### 연결리스트

단방향 연결리스트와 양방향 연결리스트가 있다.

- 단방향 연결리스트에서 각 노드는 다음 노드를 가리킨다.

- 양방향 연결리스트에서 각 노드는 다음 노드와 이전 노드를 함께 가리킨다.

  배열과 달리 연결리스트에선 특정 인덱스를 상수 시간에 접근할 수 없다. K번째 원소를 찾고싶다면 K번 루프를 돌아야 한다. 그럼에도 쓰는 이유는 리스트의 시작 지점에서 아이템을 추가하거나 삭제하는 연산을 상수시간안에 할 수 있기 때문이다.



 **Runner 기법**

연결리스트를 순회할 때 두개의 포인터를 동시에 사용해서 원소를 재배치하는 등의 일을 수행하는 방법이다.



**재귀문제**

연결 리스트 관련 문제들중 상당수가 재귀호출에 의존한다.



**예제 문제**

1. 중복 없애기 - 정렬되어있지 않은 연결리스트가 주어졌을 때 이 리스트에서 중복되는 원소를 제거하는 코드를 작성하라

   원소들을 해시테이블에 넣으면서 순회해서 이미 해시테이블에 있는 원소를 가진 노드를 없앤다.

2. 뒤에서 k번째 원소 구하기 - 단방향 연결리스트가 주어졌을 때 뒤에서 k번째 원소를 찾는 알고리즘

   2개의 포인터를 사용해서 앞에 있는 포인터와 k만큼 뒤에 있는 포인터를 차례로 다음다음으로 넘기다가 앞에 있는 포인터가 끝에 도달하면 뒤에 있는 포인터가 가리키는 원소를 찾을 수 있다.

3. 중간 노드 삭제 - 단방향 연결 리스트가 주어졌을 때 중간에 있는 노드 하나를 삭제하는 알고리즘을 구현하라. 단 삭제할 노드에만 접근할 수 있다.

   현재 노드에 다음노드의 데이터를 복사하고 다음 노드를 지운다.

4. 분할 - 값 x가 주어졌을 때 x보다 작은 노드들을 x보다 크거나 같은 노드들보다 앞에 오도록 하는 코드를 작성하라. x가 리스트에 있다면 x는 그보다 작은 원소들보다 뒤에 나오기만 하면 된다.

   새로운 노드 포인터 head와 tail 2개를 선언한다. 그리고 연결 리스트를 순회하면서 x보다 작으면 haed에 붙이고 같거나 크면 tail에 붙인다. 마지막엔 head의 next가 tail을 가리키게한다.